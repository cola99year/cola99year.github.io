(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{319:function(t,n,v){t.exports=v.p+"assets/img/image-20230525120453734.0d03966f.png"},396:function(t,n,v){"use strict";v.r(n);var s=v(3),_=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"_1-可变参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-可变参数"}},[t._v("#")]),t._v(" 1. 可变参数")]),t._v(" "),n("ol",[n("li",[t._v("可变参数：不确定个数的参数")]),t._v(" "),n("li",[t._v("在调用的时候，可以传0到多个参数")]),t._v(" "),n("li",[t._v("可变参数要放在最后一个参数的位置，放在前边的话编译器不能识别确定前面到底有几个参数")]),t._v(" "),n("li",[t._v("可变参数"),n("strong",[t._v("在方法中")]),t._v("当"),n("strong",[t._v("数组")]),t._v("使用")])]),t._v(" "),n("p",[t._v("如下例子的"),n("code",[t._v("test()")]),t._v("方法！")]),t._v(" "),n("img",{staticStyle:{zoom:"67%"},attrs:{src:v(319),alt:"image-20230525120453734"}}),t._v(" "),n("p",[t._v("命令行传参：就是在程序运行时候，可以用用cmd命令窗口传递一些参数到哪一个类里面。")]),t._v(" "),n("h2",{attrs:{id:"_2-为何在实体类重写tostring-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-为何在实体类重写tostring-方法"}},[t._v("#")]),t._v(" 2. 为何在实体类重写toString()方法？")]),t._v(" "),n("p",[t._v("如果在类中没有重写toString方法，默认使用的是Object底层自带的toString方法输出格式。这个时候，对象就会直接显示hash码。")]),t._v(" "),n("p",[t._v("如果在类中重写一个toString方法，那么输出格式就会按照我们定义的方式输出这个对象！")]),t._v(" "),n("h2",{attrs:{id:"_3-有参与无参构造器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-有参与无参构造器"}},[t._v("#")]),t._v(" 3. 有参与无参构造器")]),t._v(" "),n("ol",[n("li",[t._v("new对象本质在调用构造器。"),n("strong",[t._v("构造器又名构造方法")]),t._v("、构造函数")]),t._v(" "),n("li",[t._v("构造方法"),n("strong",[t._v("特点")]),t._v("如下：")])]),t._v(" "),n("ul",[n("li",[t._v("名字"),n("strong",[t._v("与类名")]),t._v("相同；")]),t._v(" "),n("li",[n("strong",[t._v("没有返回值")]),t._v("："),n("strong",[t._v("也不能用 void 声明构造函数")]),t._v("。")]),t._v(" "),n("li",[t._v("生成类的对象时自动执行，无需调用。")])]),t._v(" "),n("p",[t._v("构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。")]),t._v(" "),n("p",[n("strong",[t._v("作用")]),t._v("：作用是完成对象的初始化工作。")]),t._v(" "),n("blockquote",[n("p",[t._v("判断对错：构造函数必须与类同名，方法不能与类同名")]),t._v(" "),n("p",[t._v("​\t\t\t\t\t错误。构造函数就是一个方法，当然是与类同名！")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//Person.java\npublic class Person {\n    private int age;\n\n    public Person(int age) {\n        this.age = age;\n    }\n}\n\n//Student.java\npublic class Student  {\n    public static void main(String[] args) {\n        \n        Person person1 = new Person(12);//正确,本质调用有参构造器\n        \n        Person person2 = new Person();//报错，Person类在存在有参构造器的情况下，没有显式地写出无参构造器！！\n    }\n}\n")])])]),n("p",[t._v("系统默认自带无参构造器，而且你new的时候很多情况用的是无参构造器。一旦我们写了一个带参构造方法，那么就会覆盖了系统自带的无参构造方法，如果这个时候使用无参构造方法（new的话），那么编译会报错。")]),t._v(" "),n("p",[t._v("所有我们写有参构造器的时候，还有给他补回一个无参构造器！就可以应付这些情况了。")])])}),[],!1,null,null,null);n.default=_.exports}}]);