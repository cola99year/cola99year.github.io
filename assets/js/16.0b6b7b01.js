(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{345:function(t,s,a){t.exports=a.p+"assets/img/image-20230525115636578.59c0bf76.png"},346:function(t,s,a){t.exports=a.p+"assets/img/65c6d9ff5579cf5a9d2f27d6bd552998e6802110.9857fac0.gif"},408:function(t,s,a){"use strict";a.r(s);var n=a(3),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("参考文章："),s("a",{attrs:{href:"https://blog.csdn.net/jianyuerensheng/article/details/51602015?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%B9%B6%E8%A6%86%E7%9B%96%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%90%8C%E4%B8%80%E6%96%B9%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-51602015.142%5Ev14%5Epc_search_result_control_group,157%5Ev14%5Enew_3&spm=1018.2226.3001.4187",target:"_blank",rel:"noopener noreferrer"}},[t._v("面向对象编程三大特性------封装、继承、多态"),s("OutboundLink")],1),t._v("；")]),t._v(" "),s("h2",{attrs:{id:"一、面向对象的多态性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、面向对象的多态性"}},[t._v("#")]),t._v(" 一、面向对象的多态性")]),t._v(" "),s("blockquote",[s("p",[t._v("多态性 = 编译时多态 + 运行时多态")]),t._v(" "),s("p",[t._v("多态的作用：")]),t._v(" "),s("p",[t._v("1、提高了代码的维护性(继承保证)")]),t._v(" "),s("p",[t._v("2、提高了代码的扩展性(由多态保证)")]),t._v(" "),s("p",[t._v("3、把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。")])]),t._v(" "),s("p",[t._v("非面向对象的--------编译时多态："),s("strong",[t._v("编译器在编译时就决定了目标方法")]),t._v("。如方法的重载例子：")]),t._v(" "),s("p",[s("img",{attrs:{src:a(345),alt:"image-20230525115636578"}})]),t._v(" "),s("blockquote",[s("p",[t._v("Java面向对象中的多态：")])]),t._v(" "),s("p",[t._v("概念：所谓多态就是指：程序中定义的引用变量所指向的具体类型和通过该引用变量"),s("strong",[t._v("发出的方法调用在编程时并不确定，而是在程序运行期间才确定。")])]),t._v(" "),s("p",[t._v("一个引用变量到底会指向哪个类的实例对象？该引"),s("strong",[t._v("用变量发出的方法调用")]),t._v("到底是哪个类中实现的方法？必须在由程序运行期间才能决定！")]),t._v(" "),s("h2",{attrs:{id:"二、java-中两种形式可以实现多态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、java-中两种形式可以实现多态"}},[t._v("#")]),t._v(" 二、Java 中两种形式可以实现多态：")]),t._v(" "),s("h3",{attrs:{id:"_1-接口-实现接口并覆盖接口中同一方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-接口-实现接口并覆盖接口中同一方法"}},[t._v("#")]),t._v(" 1. 接口（实现接口并覆盖接口中同一方法）")]),t._v(" "),s("p",[t._v("编译时，发现方法是接口的；运行时，发现了是实现类实现了方法。真正执行的是实现类的方法。")]),t._v(" "),s("h3",{attrs:{id:"_2-继承-多个子类对同一方法的重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-继承-多个子类对同一方法的重写"}},[t._v("#")]),t._v(" 2. 继承（多个子类对同一方法的重写）")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("实现多态前提为")]),t._v("：继承（①有继承关系   ②有方法的重写）")]),t._v(" "),s("p",[s("strong",[t._v("怎样触发多态")]),t._v("：A a =New B()；这个就是父类的引用指向自己的子类。")])]),t._v(" "),s("ul",[s("li",[t._v("编译时多态：编译器在编译时就决定了目标方法")]),t._v(" "),s("li",[t._v("运行时多态：编译器在运行时，决定的目标方法。")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//编译时，看这个方法到底是谁的，是看左边的，是Person的")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" p2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Student")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\np2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//运行时，JVM运行时发现Student重写了这个方法，然后真正执行是右边对象的方法")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//使用子父亲类共同的方法时，子类重写了，就用子类；")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//子类没有重写，用父类。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//注意静态情况。")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//如果这个父类用了子类独有的方法，那么父类必定需要被强制转换为子类的对象，高转低。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Student")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("p2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),s("p",[t._v("低转高：子类也能转换为父类，但可能会丢失自己的一些方法。")]),t._v(" "),s("p",[t._v("看图："),s("strong",[t._v("编译时，方法跳转到的是父类，运行时，输出的是子类！！！")])]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(346),alt:"65c6d9ff5579cf5a9d2f27d6bd552998e6802110"}})])}),[],!1,null,null,null);s.default=e.exports}}]);